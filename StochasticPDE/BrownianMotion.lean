/-
Copyright (c) 2025 ModularPhysics. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import StochasticPDE.Basic
import StochasticPDE.Probability.Basic
import StochasticPDE.Probability.IndependenceHelpers
import Mathlib.Probability.Independence.Basic
import Mathlib.MeasureTheory.Group.MeasurableEquiv
import StochasticPDE.Helpers.SetIntegralHelpers
import Mathlib.MeasureTheory.Measure.CharacteristicFunction
import Mathlib.Analysis.SpecialFunctions.Pow.Real

/-!
# Brownian Motion and Wiener Processes

This file defines Brownian motion, cylindrical Wiener processes,
and related constructions for SPDEs.

## Main Definitions

* `BrownianMotion` - Standard Brownian motion / Wiener process
* `CylindricalWienerProcess` - Cylindrical Wiener process on a Hilbert space
* `QWienerProcess` - Q-Wiener process with covariance operator Q

## Mathematical Properties

A standard Brownian motion W_t is characterized by:
1. W_0 = 0 a.s.
2. Continuous sample paths a.s.
3. Independent increments: W_t - W_s is independent of F_s for s ≤ t
4. Gaussian increments: W_t - W_s ~ N(0, t-s) for s ≤ t

## References

* Karatzas, Shreve, "Brownian Motion and Stochastic Calculus"
* Da Prato, Zabczyk, "Stochastic Equations in Infinite Dimensions"
-/

namespace SPDE

open MeasureTheory ProbabilityTheory SPDE.Probability

variable {Ω : Type*} [MeasurableSpace Ω]

/-! ## Brownian Motion -/

-- Use SPDE.Probability.IsGaussian for Gaussian distribution characterization

/-- Standard Brownian motion (Wiener process).

    A process W : [0, ∞) × Ω → ℝ satisfying:
    1. W_0 = 0 a.s.
    2. Continuous sample paths a.s.
    3. Independent increments: for 0 ≤ s < t, the increment W_t - W_s is
       independent of the σ-algebra F_s = σ(W_u : u ≤ s)
    4. Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t

    These four properties uniquely characterize Brownian motion (in distribution).
    Note: Stationarity follows from (4): the distribution of W_t - W_s depends
    only on t - s, not on s or t individually. -/
structure BrownianMotion (Ω : Type*) [MeasurableSpace Ω] (μ : Measure Ω) where
  /-- The underlying filtration (natural filtration of W) -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F ℝ
  /-- Initial condition: W_0 = 0 a.s. -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths a.s. -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)

  /-- Independent increments: W_t - W_s is independent of F_s for s ≤ t.
      Expressed as: the σ-algebra generated by the increment is independent
      of F_s in the sense of Mathlib's `Indep`. -/
  independent_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    Indep (F.σ_algebra s) (MeasurableSpace.comap (fun ω => toAdapted.process t ω - toAdapted.process s ω) inferInstance) μ

  /-- Gaussian increments: W_t - W_s ~ N(0, t-s) for 0 ≤ s ≤ t.
      This implies both zero mean and variance = t - s. -/
  gaussian_increments : ∀ s t : ℝ, 0 ≤ s → s ≤ t →
    Probability.IsGaussian (fun ω => toAdapted.process t ω - toAdapted.process s ω) μ 0 (t - s)

  /-- Convention for non-positive times: the process equals 0 a.s.
      Standard Brownian motion is defined on [0, ∞). For t ≤ 0, we set W_t = 0.
      This is consistent with W_0 = 0 (the `initial` field) and allows the
      martingale property to hold for all s ≤ t (not just 0 ≤ s ≤ t). -/
  nonneg_time : ∀ t : ℝ, t ≤ 0 → ∀ᵐ ω ∂μ, toAdapted.process t ω = 0

/-- Alternative characterization using the product measure formulation of independence:
    For disjoint intervals, the increments are independent. -/
def BrownianMotion.disjoint_independent {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) :
    ∀ s₁ t₁ s₂ t₂ : ℝ, 0 ≤ s₁ → s₁ ≤ t₁ → t₁ ≤ s₂ → s₂ ≤ t₂ →
    IndepFun (fun ω => W.toAdapted.process t₁ ω - W.toAdapted.process s₁ ω)
             (fun ω => W.toAdapted.process t₂ ω - W.toAdapted.process s₂ ω) μ := by
  intro s₁ t₁ s₂ t₂ hs₁ ht₁ hs₂ ht₂
  -- The second increment is independent of F_{s₂} ⊇ F_{t₁} ⊇ σ(first increment)
  -- Step 1: The first increment is F_{s₂}-measurable
  have hW_t1 : @Measurable Ω ℝ (W.F.σ_algebra s₂) _ (W.toAdapted.process t₁) :=
    (W.toAdapted.adapted t₁).mono (W.F.mono t₁ s₂ hs₂) le_rfl
  have hW_s1 : @Measurable Ω ℝ (W.F.σ_algebra s₂) _ (W.toAdapted.process s₁) :=
    (W.toAdapted.adapted s₁).mono (W.F.mono s₁ s₂ (le_trans ht₁ hs₂)) le_rfl
  have hincr1_meas : @Measurable Ω ℝ (W.F.σ_algebra s₂) _
      (fun ω => W.toAdapted.process t₁ ω - W.toAdapted.process s₁ ω) :=
    hW_t1.sub hW_s1
  -- Step 2: The second increment is independent of F_{s₂}
  have hs₂_pos : 0 ≤ s₂ := le_trans (le_trans hs₁ ht₁) hs₂
  have hindep := W.independent_increments s₂ t₂ hs₂_pos ht₂
  -- Step 3: Combine via bridge lemma
  exact Probability.indepFun_of_measurable_and_indep hincr1_meas hindep

/-- Stationary increments: W_{t+h} - W_t has the same distribution as W_h - W_0 = W_h.
    This follows from the Gaussian characterization. -/
theorem BrownianMotion.stationary_increments {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∀ s t : ℝ, 0 ≤ s → 0 ≤ t →
    Measure.map (fun ω => W.toAdapted.process (s + t) ω - W.toAdapted.process s ω) μ =
    Measure.map (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ := by
  intro s t hs ht
  -- Both increments are N(0, t) by gaussian_increments
  have hg1 := W.gaussian_increments s (s + t) hs (le_add_of_nonneg_right ht)
  have hg2 := W.gaussian_increments 0 t (le_refl 0) ht
  -- Both have variance = t (after simplification)
  have hv1 : s + t - s = t := by ring
  have hv2 : t - 0 = t := by ring
  -- Measurability of both increments
  have hf₁_meas : Measurable (fun ω => W.toAdapted.process (s + t) ω - W.toAdapted.process s ω) :=
    ((W.toAdapted.adapted (s + t)).mono (W.F.le_ambient _) le_rfl).sub
      ((W.toAdapted.adapted s).mono (W.F.le_ambient _) le_rfl)
  have hf₂_meas : Measurable (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) :=
    ((W.toAdapted.adapted t).mono (W.F.le_ambient _) le_rfl).sub
      ((W.toAdapted.adapted 0).mono (W.F.le_ambient _) le_rfl)
  -- The pushforward measures are finite (probability measures)
  haveI : IsProbabilityMeasure (Measure.map (fun ω => W.toAdapted.process (s + t) ω -
      W.toAdapted.process s ω) μ) :=
    Measure.isProbabilityMeasure_map hf₁_meas.aemeasurable
  haveI : IsProbabilityMeasure (Measure.map (fun ω => W.toAdapted.process t ω -
      W.toAdapted.process 0 ω) μ) :=
    Measure.isProbabilityMeasure_map hf₂_meas.aemeasurable
  -- Apply characteristic function uniqueness (Mathlib)
  apply Measure.ext_of_charFun
  funext u
  -- Helper: compute charFun of pushforward in terms of IsGaussian.char_function
  have charFun_eq : ∀ (f : Ω → ℝ) (mean var : ℝ) (hg : Probability.IsGaussian f μ mean var)
      (hf : Measurable f),
      charFun (Measure.map f μ) u =
      Complex.exp (Complex.I * ↑u * ↑mean - ↑var * ↑u ^ 2 / 2) := by
    intro f mean var hg hf
    rw [charFun_apply_real]
    rw [integral_map_of_stronglyMeasurable hf (by fun_prop)]
    -- Beta reduction + commutativity rewrite
    have : ∀ ω, (fun x => Complex.exp (↑u * ↑x * Complex.I)) (f ω) =
        Complex.exp (Complex.I * ↑u * ↑(f ω)) := by
      intro ω; simp only []; congr 1; ring
    simp_rw [this]
    exact hg.char_function u
  rw [charFun_eq _ 0 _ hg1 hf₁_meas, charFun_eq _ 0 _ hg2 hf₂_meas, hv1, hv2]

/-- Zero mean of increments (follows from Gaussian with mean 0) -/
theorem BrownianMotion.increment_mean_zero {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω) ∂μ = 0 :=
  (W.gaussian_increments s t hs hst).mean_eq

/-- Variance of increments (follows from Gaussian with variance t-s) -/
theorem BrownianMotion.increment_variance {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
    (W : BrownianMotion Ω μ) (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t) :
    ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω)^2 ∂μ = t - s := by
  have h := (W.gaussian_increments s t hs hst).variance_eq
  simp only [sub_zero] at h
  exact h

namespace BrownianMotion

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}

/-- The process underlying Brownian motion -/
def process (W : BrownianMotion Ω μ) : ℝ → Ω → ℝ := W.toAdapted.process

/-- Brownian increments are integrable (follows from Gaussian integrability) -/
theorem increment_integrable (W : BrownianMotion Ω μ) (s t : ℝ)
    (hs : 0 ≤ s) (hst : s ≤ t) :
    Integrable (fun ω => W.toAdapted.process t ω - W.toAdapted.process s ω) μ :=
  (W.gaussian_increments s t hs hst).integrable

/-- Brownian increments are square-integrable (follows from Gaussian all_moments) -/
theorem increment_sq_integrable (W : BrownianMotion Ω μ) (s t : ℝ)
    (hs : 0 ≤ s) (hst : s ≤ t) :
    Integrable (fun ω => (W.toAdapted.process t ω - W.toAdapted.process s ω)^2) μ :=
  (W.gaussian_increments s t hs hst).all_moments 2

/-- Brownian increments have all moments -/
theorem increment_all_moments (W : BrownianMotion Ω μ) (s t : ℝ)
    (hs : 0 ≤ s) (hst : s ≤ t) (n : ℕ) :
    Integrable (fun ω => (W.toAdapted.process t ω - W.toAdapted.process s ω)^n) μ :=
  (W.gaussian_increments s t hs hst).all_moments n

/-- Brownian motion is a martingale.

    The martingale property E[W_t | F_s] = W_s follows from:
    1. W_t = W_s + (W_t - W_s)
    2. W_s is F_s-measurable
    3. W_t - W_s is independent of F_s (by independent_increments)
    4. E[W_t - W_s] = 0 (by gaussian_increments with mean 0)
    Therefore E[W_t | F_s] = W_s + E[W_t - W_s | F_s] = W_s + E[W_t - W_s] = W_s + 0 = W_s

    **Note**: The current BrownianMotion structure is indexed by ℝ but only defines
    properties (gaussian_increments, independent_increments) for 0 ≤ s ≤ t.
    A cleaner approach would be to index by ℝ≥0, but this would require refactoring
    the Filtration and related structures. For now, we handle the t < 0 case with sorry.

    **Required infrastructure**:
    - Independence implies integral factorization: for A ∈ F_s and X independent of F_s,
      ∫_A X dμ = μ(A) * ∫ X dμ. This is in Mathlib as `IndepFun.integral_mul_eq_mul_integral`
      but we need to connect `Indep` (σ-algebra independence) to this. -/
theorem is_martingale (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∃ M : Martingale W.F μ ℝ, M.process = W.process := by
  use {
    toAdapted := W.toAdapted
    integrable := fun t => by
      by_cases ht : t ≥ 0
      · have hgauss := W.gaussian_increments 0 t (le_refl 0) ht
        have hincr : Integrable (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ :=
          hgauss.integrable
        have heq : (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) =ᶠ[ae μ]
                   W.toAdapted.process t := by
          filter_upwards [W.initial] with ω h0; simp [h0]
        exact hincr.congr heq
      · -- t < 0: by nonneg_time, W_t = 0 a.s., so W_t is integrable
        push_neg at ht
        have heq : W.toAdapted.process t =ᶠ[ae μ] (fun _ => (0 : ℝ)) := by
          filter_upwards [W.nonneg_time t (le_of_lt ht)] with ω h0; exact h0
        exact (integrable_const (0 : ℝ)).congr heq.symm
    martingale_property := fun s t hst A hA => by
      by_cases hs : s ≥ 0
      · -- Key: ∫_A W_t dμ = ∫_A W_s dμ, equivalently ∫_A (W_t - W_s) dμ = 0
        have hgauss := W.gaussian_increments s t hs hst
        have hmean : ∫ ω, (W.toAdapted.process t ω - W.toAdapted.process s ω) ∂μ = 0 :=
          hgauss.mean_eq
        have hindep := W.independent_increments s t hs hst
        -- hindep : Indep (F.σ_algebra s) (comap increment) μ
        -- We need the symmetric: Indep (comap increment) (F.σ_algebra s) μ
        have hindep_symm := hindep.symm
        -- Define the increment function
        let incr := fun ω => W.toAdapted.process t ω - W.toAdapted.process s ω
        -- Show the increment integral over A is zero
        have hm₂ : W.F.σ_algebra s ≤ ‹MeasurableSpace Ω› := W.F.le_ambient s
        -- SigmaFinite instance: finite measure trim is sigma-finite
        haveI : SigmaFinite (μ.trim hm₂) := inferInstance
        -- The increment is strongly measurable w.r.t. its comap σ-algebra
        have hincr_sm : StronglyMeasurable[MeasurableSpace.comap incr inferInstance] incr :=
          _root_.SPDE.Probability.stronglyMeasurable_comap_self incr
        -- The comap σ-algebra is ≤ ambient
        have hm₁ : MeasurableSpace.comap incr inferInstance ≤ ‹MeasurableSpace Ω› := by
          apply MeasurableSpace.comap_le_iff_le_map.mpr
          intro s' hs'
          -- incr = W_t - W_s is measurable since W_t and W_s are measurable
          have hWt : Measurable (W.toAdapted.process t) :=
            (W.toAdapted.adapted t).mono (W.F.le_ambient t) le_rfl
          have hWs : Measurable (W.toAdapted.process s) :=
            (W.toAdapted.adapted s).mono (W.F.le_ambient s) le_rfl
          exact (hWt.sub hWs) hs'
        have hincr_int := hgauss.integrable
        -- Apply the key lemma: ∫_A incr dμ = 0
        have hzero : ∫ ω in A, incr ω ∂μ = 0 :=
          Probability.setIntegral_eq_zero_of_indep_zero_mean hm₁ hm₂ hincr_sm hincr_int hindep_symm hmean A hA
        -- Now show ∫_A W_t = ∫_A W_s
        have hWt_int : Integrable (W.toAdapted.process t) μ := by
          have h0 := W.gaussian_increments 0 t (le_refl 0) (le_trans hs hst)
          have hincr0 : Integrable (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) μ := h0.integrable
          have heq : (fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω) =ᶠ[ae μ] W.toAdapted.process t := by
            filter_upwards [W.initial] with ω h0'; simp [h0']
          exact hincr0.congr heq
        have hWs_int : Integrable (W.toAdapted.process s) μ := by
          have h0 := W.gaussian_increments 0 s (le_refl 0) hs
          have hincr0 : Integrable (fun ω => W.toAdapted.process s ω - W.toAdapted.process 0 ω) μ := h0.integrable
          have heq : (fun ω => W.toAdapted.process s ω - W.toAdapted.process 0 ω) =ᶠ[ae μ] W.toAdapted.process s := by
            filter_upwards [W.initial] with ω h0'; simp [h0']
          exact hincr0.congr heq
        -- ∫_A W_t = ∫_A (W_s + incr) = ∫_A W_s + ∫_A incr = ∫_A W_s + 0
        have heq' : ∀ ω, W.toAdapted.process t ω = W.toAdapted.process s ω + incr ω := by
          intro ω; simp only [incr]; ring
        -- Use that W_t = W_s + incr implies ∫_A W_t = ∫_A W_s + ∫_A incr
        have hsum : ∫ ω in A, W.toAdapted.process t ω ∂μ =
                    ∫ ω in A, W.toAdapted.process s ω ∂μ + ∫ ω in A, incr ω ∂μ := by
          have hfun_eq : (fun ω => W.toAdapted.process t ω) =
                         (fun ω => W.toAdapted.process s ω + incr ω) := funext heq'
          rw [hfun_eq]
          exact integral_add hWs_int.integrableOn hincr_int.integrableOn
        rw [hsum, hzero, add_zero]
      · -- s < 0 case: W_s = 0 a.s. by nonneg_time
        push_neg at hs
        -- ∫_A W_s = ∫_A 0 = 0
        have hWs_zero : ∫ ω in A, W.toAdapted.process s ω ∂μ = 0 := by
          have heq : ∫ ω in A, W.toAdapted.process s ω ∂μ =
                     ∫ ω in A, (0 : ℝ) ∂μ := by
            apply setIntegral_congr_ae (W.F.le_ambient s A hA)
            filter_upwards [W.nonneg_time s (le_of_lt hs)] with ω h0 _
            exact h0
          rw [heq]; simp
        -- Now show ∫_A W_t = 0
        have hWt_zero : ∫ ω in A, W.toAdapted.process t ω ∂μ = 0 := by
          by_cases ht : t ≤ 0
          · -- Both s, t ≤ 0: W_t = 0 a.s. too
            have heq : ∫ ω in A, W.toAdapted.process t ω ∂μ =
                       ∫ ω in A, (0 : ℝ) ∂μ := by
              apply setIntegral_congr_ae (W.F.le_ambient s A hA)
              filter_upwards [W.nonneg_time t ht] with ω h0 _
              exact h0
            rw [heq]; simp
          · -- s < 0 < t: W_t = (W_t - W_0) a.s. since W_0 = 0
            push_neg at ht
            have ht' : 0 ≤ t := le_of_lt ht
            -- A ∈ F_s ⊆ F_0 (since s ≤ 0)
            have hA0 : @MeasurableSet Ω (W.F.σ_algebra 0) A :=
              (W.F.mono s 0 (le_of_lt hs)) A hA
            -- W_t =ᵃᵉ (W_t - W_0) since W_0 = 0 a.s.
            have hWt_eq : ∫ ω in A, W.toAdapted.process t ω ∂μ =
                ∫ ω in A, (W.toAdapted.process t ω - W.toAdapted.process 0 ω) ∂μ := by
              apply setIntegral_congr_ae (W.F.le_ambient 0 A hA0)
              filter_upwards [W.initial] with ω h0 _
              simp [h0]
            rw [hWt_eq]
            -- The increment W_t - W_0 is independent of F_0 with zero mean
            set incr0 := fun ω => W.toAdapted.process t ω - W.toAdapted.process 0 ω
            have hm₂ : W.F.σ_algebra 0 ≤ ‹MeasurableSpace Ω› := W.F.le_ambient 0
            haveI : SigmaFinite (μ.trim hm₂) := inferInstance
            have hincr0_sm : StronglyMeasurable[MeasurableSpace.comap incr0 inferInstance] incr0 :=
              _root_.SPDE.Probability.stronglyMeasurable_comap_self incr0
            have hm₁ : MeasurableSpace.comap incr0 inferInstance ≤ ‹MeasurableSpace Ω› := by
              apply MeasurableSpace.comap_le_iff_le_map.mpr
              intro s' hs'
              exact (((W.toAdapted.adapted t).mono (W.F.le_ambient t) le_rfl).sub
                ((W.toAdapted.adapted 0).mono (W.F.le_ambient 0) le_rfl)) hs'
            have hincr0_int := (W.gaussian_increments 0 t (le_refl 0) ht').integrable
            have hindep0 := (W.independent_increments 0 t (le_refl 0) ht').symm
            have hmean0 := W.increment_mean_zero 0 t (le_refl 0) ht'
            exact Probability.setIntegral_eq_zero_of_indep_zero_mean
              hm₁ hm₂ hincr0_sm hincr0_int hindep0 hmean0 A hA0
        rw [hWt_zero, hWs_zero]
  }
  rfl

/-- The quadratic variation of Brownian motion is t.

    The QV is constructed with `variation t ω = t` (deterministic). This satisfies:
    - Adapted: constant function is measurable w.r.t. any σ-algebra
    - Monotone: t ↦ t is monotone
    - Initial: 0 = 0

    The compensator property (W²_t - t is a submartingale) can be verified
    separately using `qv.is_compensator`. -/
theorem quadratic_variation (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∃ qv : QuadraticVariation W.F,
      qv.process = W.process ∧
      (∀ t : ℝ, ∀ᵐ ω ∂μ, qv.variation t ω = t) := by
  use {
    process := W.process
    variation := fun t _ω => t
    adapted := fun _t => measurable_const
    mono := fun _ω => monotone_id
    initial := fun _ω => rfl
  }
  exact ⟨rfl, fun t => by filter_upwards with ω; rfl⟩

/-- W²_t - t is a martingale (compensator property of BM quadratic variation).

    This is the mathematically substantive content: for 0 ≤ s ≤ t and A ∈ F_s,
    ∫_A (W_t² - t) dμ = ∫_A (W_s² - s) dμ.

    **Proof**:
    W_t = W_s + ΔW where ΔW = W_t - W_s.
    W_t² = W_s² + 2·W_s·ΔW + (ΔW)²
    ∫_A W_t² = ∫_A W_s² + 2·∫_A(W_s·ΔW) + ∫_A(ΔW)²
    Cross term: ∫_A(W_s·ΔW) = 0 (W_s adapted, ΔW independent with zero mean)
    Variance term: ∫_A(ΔW)² = (t-s)·μ(A)
    So ∫_A(W_t² - t) = ∫_A W_s² + (t-s)·μ(A) - t·μ(A) = ∫_A W_s² - s·μ(A) = ∫_A(W_s² - s) -/
theorem quadratic_variation_compensator (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ]
    (s t : ℝ) (hs : 0 ≤ s) (hst : s ≤ t)
    (A : Set Ω) (hA : @MeasurableSet Ω (W.F.σ_algebra s) A) :
    ∫ ω in A, ((W.process t ω)^2 - t) ∂μ =
    ∫ ω in A, ((W.process s ω)^2 - s) ∂μ := by
  -- Use toAdapted.process throughout (process is defined as toAdapted.process)
  show ∫ ω in A, ((W.toAdapted.process t ω)^2 - t) ∂μ =
       ∫ ω in A, ((W.toAdapted.process s ω)^2 - s) ∂μ
  set incr := fun ω => W.toAdapted.process t ω - W.toAdapted.process s ω with incr_def
  -- Key integrability and measure-theoretic facts
  have hWs_meas : @Measurable Ω ℝ (W.F.σ_algebra s) _ (W.toAdapted.process s) :=
    W.toAdapted.adapted s
  have hWs_int : Integrable (W.toAdapted.process s) μ :=
    (W.gaussian_increments 0 s (le_refl 0) hs).integrable.congr
      (by filter_upwards [W.initial] with ω h0'; simp [h0'])
  have hWs_sq_int : Integrable (fun ω => (W.toAdapted.process s ω)^2) μ :=
    ((W.gaussian_increments 0 s (le_refl 0) hs).all_moments 2).congr
      (by filter_upwards [W.initial] with ω h0'; simp [h0'])
  have hincr_int : Integrable incr μ := W.increment_integrable s t hs hst
  have hincr_sq_int : Integrable (fun ω => (incr ω)^2) μ :=
    W.increment_sq_integrable s t hs hst
  have hindep := W.independent_increments s t hs hst
  have hmean : ∫ ω, incr ω ∂μ = 0 := W.increment_mean_zero s t hs hst
  have hvar : ∫ ω, (incr ω)^2 ∂μ = t - s := W.increment_variance s t hs hst
  -- Product integrability via AM-GM: |a·b| ≤ a² + b²
  have hprod_int : Integrable (fun ω => W.toAdapted.process s ω * incr ω) μ :=
    (hWs_sq_int.add hincr_sq_int).mono'
      (hWs_int.aestronglyMeasurable.mul hincr_int.aestronglyMeasurable)
      (ae_of_all _ fun ω => by
        simp only [Real.norm_eq_abs, Pi.add_apply]
        rw [abs_mul]
        nlinarith [sq_abs (W.toAdapted.process s ω), sq_abs (incr ω),
                    sq_nonneg (|W.toAdapted.process s ω| - |incr ω|),
                    abs_nonneg (W.toAdapted.process s ω), abs_nonneg (incr ω)])
  -- Cross term vanishes: ∫_A W_s·ΔW = 0
  have hcross : ∫ ω in A, W.toAdapted.process s ω * incr ω ∂μ = 0 :=
    Probability.setIntegral_mul_zero_of_adapted_and_indep_zero_mean
      (W.F.le_ambient s) hWs_meas hA hWs_int.integrableOn hincr_int hindep hmean
  -- SigmaFinite for trimmed measure (probability → finite → sigma-finite)
  have hm₂ : W.F.σ_algebra s ≤ ‹MeasurableSpace Ω› := W.F.le_ambient s
  haveI : SigmaFinite (μ.trim hm₂) := inferInstance
  -- Variance set integral: ∫_A (ΔW)² = (t-s)·μ(A)
  have hincr_meas : Measurable incr :=
    ((W.toAdapted.adapted t).mono (W.F.le_ambient t) le_rfl).sub
      ((W.toAdapted.adapted s).mono (W.F.le_ambient s) le_rfl)
  have hvar_set : ∫ ω in A, (incr ω)^2 ∂μ = (μ A).toReal * (t - s) := by
    rw [Probability.setIntegral_sq_of_indep_eq_measure_mul_integral
      (W.F.le_ambient s) hincr_meas hincr_sq_int hindep A hA, hvar]
  -- Main computation: suffices to show the difference = 0
  suffices hdiff : ∫ ω in A, ((W.toAdapted.process t ω)^2 - t) ∂μ -
                   ∫ ω in A, ((W.toAdapted.process s ω)^2 - s) ∂μ = 0 by linarith
  -- W_t² integrability (W_t = W_s + incr, so W_t² = (W_s + incr)² is integrable)
  have hWt_sq_int : Integrable (fun ω => (W.toAdapted.process t ω)^2) μ := by
    have heq : (fun ω => (W.toAdapted.process t ω)^2) =
               (fun ω => (W.toAdapted.process s ω)^2 +
                 2 * (W.toAdapted.process s ω * incr ω) + (incr ω)^2) := by
      ext ω; simp only [incr_def]; ring
    rw [heq]
    exact (hWs_sq_int.add (hprod_int.const_mul 2)).add hincr_sq_int
  have hLHS_int : IntegrableOn (fun ω => (W.toAdapted.process t ω)^2 - t) A μ :=
    (hWt_sq_int.sub (integrable_const t)).integrableOn
  have hRHS_int : IntegrableOn (fun ω => (W.toAdapted.process s ω)^2 - s) A μ :=
    (hWs_sq_int.sub (integrable_const s)).integrableOn
  -- Combine into single integral
  rw [← integral_sub hLHS_int hRHS_int]
  -- Simplify integrand: (W_t² - t) - (W_s² - s) = 2·W_s·ΔW + (ΔW² - (t-s))
  have hsimplify : ∀ ω, ((W.toAdapted.process t ω)^2 - t) -
      ((W.toAdapted.process s ω)^2 - s) =
      2 * (W.toAdapted.process s ω * incr ω) + ((incr ω)^2 - (t - s)) := by
    intro ω; simp only [incr_def]; ring
  simp_rw [hsimplify]
  -- Split integral into two terms
  have hpart1_int : IntegrableOn (fun ω => 2 * (W.toAdapted.process s ω * incr ω)) A μ :=
    (hprod_int.const_mul 2).integrableOn
  have hpart2_int : IntegrableOn (fun ω => (incr ω)^2 - (t - s)) A μ :=
    (hincr_sq_int.sub (integrable_const _)).integrableOn
  rw [integral_add hpart1_int hpart2_int]
  -- Cross term: ∫_A 2·(W_s·ΔW) = 2·∫_A (W_s·ΔW) = 2·0 = 0
  have hcross2 : ∫ ω in A, 2 * (W.toAdapted.process s ω * incr ω) ∂μ = 0 := by
    rw [integral_const_mul, hcross, mul_zero]
  -- Variance remainder: ∫_A (ΔW² - (t-s)) = (t-s)·μ(A) - (t-s)·μ(A) = 0
  have hvar_rem : ∫ ω in A, ((incr ω)^2 - (t - s)) ∂μ = 0 := by
    rw [integral_sub hincr_sq_int.integrableOn (integrable_const _).integrableOn,
        hvar_set, setIntegral_const, smul_eq_mul]
    simp only [Measure.real]
    ring
  rw [hcross2, hvar_rem, add_zero]

/-- Brownian scaling: if W_t is a BM, then c^{-1/2} W_{ct} is also a BM -/
theorem scaling (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] (c : ℝ) (hc : 0 < c) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = c^(-(1/2 : ℝ)) * W.process (c * t) ω := by
  -- The scaling constant
  set a := c ^ (-(1/2 : ℝ)) with ha_def
  have ha_pos : 0 < a := Real.rpow_pos_of_pos hc _
  have ha_ne : a ≠ 0 := ne_of_gt ha_pos
  -- Key arithmetic: a² * c = 1
  have ha_sq_c : a ^ 2 * c = 1 := by
    rw [sq, ha_def, ← Real.rpow_add hc]
    norm_num
    rw [show (-1 : ℝ) = ((-1 : ℤ) : ℝ) from by norm_cast, Real.rpow_intCast,
        zpow_neg_one, inv_mul_cancel₀ (ne_of_gt hc)]
  -- Construct the rescaled filtration: F'_t = F_{ct}
  let F' : Filtration Ω ℝ := {
    σ_algebra := fun t => W.F.σ_algebra (c * t)
    mono := fun s t hst => W.F.mono _ _ (mul_le_mul_of_nonneg_left hst hc.le)
    le_ambient := fun t => W.F.le_ambient _
  }
  -- Construct the scaled adapted process
  let scaledW : AdaptedProcess F' ℝ := {
    process := fun t ω => a * W.toAdapted.process (c * t) ω
    adapted := fun t => (W.toAdapted.adapted (c * t)).const_mul a
  }
  -- Increment helper
  have incr_scaled : ∀ s t, (fun ω => scaledW.process t ω - scaledW.process s ω) =
      (fun ω => a * (W.toAdapted.process (c * t) ω - W.toAdapted.process (c * s) ω)) := by
    intro s t; ext ω; simp [scaledW]; ring
  -- comap(a * f) = comap(f) for a ≠ 0
  have comap_mul_eq : ∀ (g : Ω → ℝ),
      MeasurableSpace.comap (fun ω => a * (g ω)) inferInstance =
      MeasurableSpace.comap g inferInstance := by
    intro g
    change (inferInstance : MeasurableSpace ℝ).comap ((fun x => a * x) ∘ g) =
           (inferInstance : MeasurableSpace ℝ).comap g
    rw [← MeasurableSpace.comap_comp]
    congr 1
    exact (MeasurableEquiv.mulLeft₀ a ha_ne).measurableEmbedding.comap_eq
  use {
    F := F'
    toAdapted := scaledW
    initial := by
      filter_upwards [W.initial] with ω h0
      simp [scaledW, mul_zero, h0]
    continuous_paths := by
      filter_upwards [W.continuous_paths] with ω hcont
      show Continuous (fun t => a * W.toAdapted.process (c * t) ω)
      exact continuous_const.mul (hcont.comp (continuous_const.mul continuous_id))
    independent_increments := fun s t hs hst => by
      rw [incr_scaled, comap_mul_eq]
      exact W.independent_increments _ _ (mul_nonneg hc.le hs) (mul_le_mul_of_nonneg_left hst hc.le)
    gaussian_increments := fun s t hs hst => by
      rw [incr_scaled]
      -- a * (W(ct) - W(cs)) = a * IsGaussian(0, ct-cs) + 0
      have hgauss := W.gaussian_increments _ _ (mul_nonneg hc.le hs)
          (mul_le_mul_of_nonneg_left hst hc.le)
      have hg := Probability.gaussian_affine hgauss a 0
      simp only [mul_zero, add_zero] at hg
      -- hg : IsGaussian (fun ω => a * ...) μ 0 (a² * (c*t - c*s))
      have h_var : a ^ 2 * (c * t - c * s) = t - s := by nlinarith [ha_sq_c]
      rwa [h_var] at hg
    nonneg_time := fun t ht => by
      filter_upwards [W.nonneg_time (c * t) (mul_nonpos_of_nonneg_of_nonpos hc.le ht)] with ω h0
      simp [scaledW, h0]
  }
  intro t
  filter_upwards with ω
  simp [process, scaledW]

/-- Reflection principle: -W is also a Brownian motion -/
theorem reflection (W : BrownianMotion Ω μ) [IsProbabilityMeasure μ] :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, ∀ᵐ ω ∂μ, W'.process t ω = -W.process t ω := by
  -- Construct the negated adapted process
  let negW : AdaptedProcess W.F ℝ := {
    process := fun t ω => -W.toAdapted.process t ω
    adapted := fun t => (W.toAdapted.adapted t).neg
  }
  -- Helper: the increment of -W equals minus the increment of W
  have incr_neg : ∀ s t, (fun ω => negW.process t ω - negW.process s ω) =
      (fun ω => -(W.toAdapted.process t ω - W.toAdapted.process s ω)) := by
    intro s t; ext ω; simp [negW]; ring
  -- Helper: comap(-f) = comap(f) because negation is a MeasurableEquiv
  have comap_neg_eq : ∀ (g : Ω → ℝ),
      MeasurableSpace.comap (fun ω => -(g ω)) inferInstance =
      MeasurableSpace.comap g inferInstance := by
    intro g
    change (inferInstance : MeasurableSpace ℝ).comap (Neg.neg ∘ g) =
           (inferInstance : MeasurableSpace ℝ).comap g
    rw [← MeasurableSpace.comap_comp]
    congr 1
    exact (MeasurableEquiv.neg ℝ).measurableEmbedding.comap_eq
  use {
    F := W.F
    toAdapted := negW
    initial := by
      filter_upwards [W.initial] with ω h0
      simp [negW, h0]
    continuous_paths := by
      filter_upwards [W.continuous_paths] with ω hcont
      exact hcont.neg
    independent_increments := fun s t hs hst => by
      rw [incr_neg, comap_neg_eq]
      exact W.independent_increments s t hs hst
    gaussian_increments := fun s t hs hst => by
      rw [incr_neg]
      -- -(W_t - W_s) = (-1) * (W_t - W_s) + 0
      have hfun : (fun ω => -(W.toAdapted.process t ω - W.toAdapted.process s ω)) =
          (fun ω => (-1) * (W.toAdapted.process t ω - W.toAdapted.process s ω) + 0) := by
        ext ω; ring
      rw [hfun]
      have hg := Probability.gaussian_affine (W.gaussian_increments s t hs hst) (-1) 0
      simp only [neg_one_mul, neg_zero, add_zero, one_mul, neg_one_sq] at hg
      (convert hg using 2; ring)
    nonneg_time := fun t ht => by
      filter_upwards [W.nonneg_time t ht] with ω h0
      simp [negW, h0]
  }
  intro t
  filter_upwards with ω
  simp [process, negW]

/-- Time inversion: tW_{1/t} is a Brownian motion (for t > 0) -/
theorem time_inversion (W : BrownianMotion Ω μ) :
    ∃ W' : BrownianMotion Ω μ,
      ∀ t : ℝ, 0 < t → ∀ᵐ ω ∂μ, W'.process t ω = t * W.process (1/t) ω := by
  sorry

end BrownianMotion

/-! ## Multidimensional Brownian Motion -/

/-- d-dimensional Brownian motion -/
structure BrownianMotionD (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (Fin d → ℝ)
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => toAdapted.process t ω)
  /-- Covariance: E[W_t^i W_s^j] = (t ∧ s) δ_{ij} -/
  covariance : ∀ i j : Fin d, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω i) * (toAdapted.process s ω j) ∂μ =
      if i = j then min t s else 0

/-! ## Cylindrical Wiener Process -/

/-- A cylindrical Wiener process on a Hilbert space H.
    This is a generalization of Brownian motion to infinite dimensions. -/
structure CylindricalWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [MeasurableSpace (H →L[ℝ] ℝ)] where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F (H →L[ℝ] ℝ)
  /-- Initial condition: W(0) = 0 a.s. -/
  initial : ∀ h : H, ∀ᵐ ω ∂μ, toAdapted.process 0 ω h = 0
  /-- Isometry property: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨h₁, h₂⟩ -/
  isometry : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, (toAdapted.process t ω h₁) * (toAdapted.process s ω h₂) ∂μ =
      min t s * @inner ℝ H _ h₁ h₂

namespace CylindricalWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [MeasurableSpace (H →L[ℝ] ℝ)]

/-- The cylindrical Wiener process evaluated on h ∈ H gives a real-valued process -/
def eval (W : CylindricalWienerProcess Ω μ H) (h : H) : ℝ → Ω → ℝ :=
  fun t ω => W.toAdapted.process t ω h

/-- Evaluation on a unit vector gives a standard Brownian motion -/
theorem eval_unit_is_brownian (W : CylindricalWienerProcess Ω μ H) (h : H) (hh : ‖h‖ = 1) :
    ∃ B : BrownianMotion Ω μ, ∀ t : ℝ, ∀ᵐ ω ∂μ, B.process t ω = W.eval h t ω := by
  sorry

end CylindricalWienerProcess

/-! ## Q-Wiener Process -/

/-- A trace-class operator on a separable Hilbert space H.

    A bounded linear operator Q : H → H is trace-class if:
    1. Q is self-adjoint: ⟨Qx, y⟩ = ⟨x, Qy⟩
    2. Q is non-negative: ⟨Qx, x⟩ ≥ 0
    3. The trace Tr(Q) = Σᵢ ⟨Qeᵢ, eᵢ⟩ is finite for any ONB {eᵢ}

    By the spectral theorem for compact self-adjoint operators, there exists
    an orthonormal basis of eigenvectors with non-negative eigenvalues λᵢ
    such that Σᵢ λᵢ < ∞. The eigenvectors and eigenvalues are bundled here
    with the constraint that they are actual eigenpairs of `toLinearMap`. -/
structure TraceClassOperator (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] where
  /-- The underlying continuous linear map -/
  toLinearMap : H →L[ℝ] H
  /-- Self-adjoint: ⟨Qh₁, h₂⟩ = ⟨h₁, Qh₂⟩ -/
  self_adjoint : ∀ h₁ h₂ : H, @inner ℝ H _ (toLinearMap h₁) h₂ = @inner ℝ H _ h₁ (toLinearMap h₂)
  /-- Non-negative: ⟨Qh, h⟩ ≥ 0 -/
  nonneg : ∀ h : H, @inner ℝ H _ (toLinearMap h) h ≥ 0
  /-- Eigenvectors forming an orthonormal system -/
  eigenvectors : ℕ → H
  /-- Eigenvalues -/
  eigenvalues : ℕ → ℝ
  /-- Eigenvalues are non-negative -/
  eigenvalues_nonneg : ∀ i, eigenvalues i ≥ 0
  /-- Eigenvalues are summable (trace-class condition) -/
  eigenvalues_summable : Summable eigenvalues
  /-- Eigenvectors are actual eigenvectors of toLinearMap:
      Q eᵢ = λᵢ eᵢ. This connects eigenvalues to the operator. -/
  is_eigenpair : ∀ i, toLinearMap (eigenvectors i) = eigenvalues i • eigenvectors i
  /-- Eigenvectors are pairwise orthogonal -/
  eigenvectors_orthogonal : ∀ i j, i ≠ j →
    @inner ℝ H _ (eigenvectors i) (eigenvectors j) = 0
  /-- Eigenvectors with non-zero eigenvalue have unit norm -/
  eigenvectors_normalized : ∀ i, eigenvalues i > 0 → ‖eigenvectors i‖ = 1

/-- The trace is the sum of eigenvalues -/
noncomputable def TraceClassOperator.trace {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] (Q : TraceClassOperator H) : ℝ := ∑' i, Q.eigenvalues i

namespace TraceClassOperator

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H]

/-- The trace is non-negative -/
theorem trace_nonneg (Q : TraceClassOperator H) : Q.trace ≥ 0 := by
  apply tsum_nonneg
  exact Q.eigenvalues_nonneg

/-- Zero operator is trace-class with trace 0 -/
def zero : TraceClassOperator H where
  toLinearMap := 0
  self_adjoint := fun _ _ => by simp
  nonneg := fun _ => by simp
  eigenvectors := fun _ => 0
  eigenvalues := fun _ => 0
  eigenvalues_nonneg := fun _ => le_refl 0
  eigenvalues_summable := summable_zero
  is_eigenpair := fun _ => by simp
  eigenvectors_orthogonal := fun _ _ _ => by simp
  eigenvectors_normalized := fun _ h => absurd h (lt_irrefl 0)

end TraceClassOperator

/-- A Q-Wiener process with covariance operator Q.
    More regular than cylindrical Wiener process when Tr(Q) < ∞. -/
structure QWienerProcess (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (H : Type*) [NormedAddCommGroup H] [InnerProductSpace ℝ H]
    [CompleteSpace H] [MeasurableSpace H] (Q : TraceClassOperator H) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The adapted process -/
  toAdapted : AdaptedProcess F H
  /-- Initial condition: W(0) = 0 a.s. -/
  initial : ∀ᵐ ω ∂μ, toAdapted.process 0 ω = 0
  /-- Covariance: E[⟨W(t), h₁⟩⟨W(s), h₂⟩] = (t ∧ s)⟨Qh₁, h₂⟩ -/
  covariance : ∀ h₁ h₂ : H, ∀ t s : ℝ, 0 ≤ t → 0 ≤ s →
    ∫ ω, @inner ℝ H _ (toAdapted.process t ω) h₁ * @inner ℝ H _ (toAdapted.process s ω) h₂ ∂μ =
      min t s * @inner ℝ H _ (Q.toLinearMap h₁) h₂

namespace QWienerProcess

variable {Ω : Type*} [MeasurableSpace Ω]
variable {μ : Measure Ω}
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H] [MeasurableSpace H]
variable {Q : TraceClassOperator H}

/-- Q-Wiener process has continuous paths in H -/
theorem continuous_paths (W : QWienerProcess Ω μ H Q) :
    ∀ᵐ ω ∂μ, Continuous (fun t => W.toAdapted.process t ω) := by
  sorry

/-- The covariance operator determines the regularity -/
theorem regularity_from_trace (W : QWienerProcess Ω μ H Q) :
    ∀ t : ℝ, 0 ≤ t → ∃ (bound : ℝ), ∫ ω, ‖W.toAdapted.process t ω‖^2 ∂μ ≤ bound := by
  sorry

end QWienerProcess

/-! ## Space-Time White Noise -/

/-- Space-time white noise on a domain D ⊆ ℝ^d -/
structure SpaceTimeWhiteNoise (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (d : ℕ) (D : Set (Fin d → ℝ)) [MeasurableSpace D] (ν : Measure D) where
  /-- The distribution W(ϕ) for test function ϕ -/
  eval : (D → ℝ) → (Ω → ℝ)
  /-- Linearity -/
  linear : ∀ a b : ℝ, ∀ ϕ ψ : D → ℝ,
    eval (fun x => a * ϕ x + b * ψ x) = fun ω => a * eval ϕ ω + b * eval ψ ω
  /-- Isometry: E[W(ϕ)W(ψ)] = ⟨ϕ, ψ⟩_{L²} -/
  isometry : ∀ ϕ ψ : D → ℝ, ∫ ω, eval ϕ ω * eval ψ ω ∂μ = ∫ x, ϕ x * ψ x ∂ν
  /-- Gaussianity: each W(ϕ) is a Gaussian random variable with mean 0 and variance ‖ϕ‖²_{L²} -/
  gaussian : ∀ ϕ : D → ℝ,
    SPDE.Probability.IsGaussian (eval ϕ) μ 0 (∫ x, (ϕ x)^2 ∂ν)

/-! ## Lévy's Characterization -/

/-- Lévy's characterization: a continuous local martingale with
    quadratic variation ⟨M⟩_t = t is a Brownian motion. -/
theorem levy_characterization {Ω : Type*} [MeasurableSpace Ω]
    {F : Filtration Ω ℝ} {μ : Measure Ω} [IsProbabilityMeasure μ]
    (M : LocalMartingale F μ ℝ)
    (continuous : ∀ᵐ ω ∂μ, Continuous (fun t => M.process t ω))
    (initial : ∀ᵐ ω ∂μ, M.process 0 ω = 0)
    (qv : QuadraticVariation F)
    (hqv_process : qv.process = M.process)
    (hqv_is_t : ∀ t : ℝ, 0 ≤ t → ∀ᵐ ω ∂μ, qv.variation t ω = t) :
    ∃ W : BrownianMotion Ω μ, W.process = M.process := by
  sorry

/-! ## Brownian Bridge -/

/-- Brownian bridge from 0 to a at time T -/
structure BrownianBridge (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (T : ℝ) (hT : 0 < T) (a : ℝ) where
  /-- The process on [0, T] -/
  process : Set.Icc 0 T → Ω → ℝ
  /-- Initial condition -/
  initial : ∀ᵐ ω ∂μ, process ⟨0, by constructor <;> linarith⟩ ω = 0
  /-- Terminal condition -/
  terminal : ∀ᵐ ω ∂μ, process ⟨T, by constructor <;> linarith⟩ ω = a
  /-- Continuous paths -/
  continuous_paths : ∀ᵐ ω ∂μ, Continuous (fun t => process t ω)
  /-- Covariance: E[B_s B_t] = s(T-t)/T for s ≤ t -/
  covariance : ∀ (s t : Set.Icc 0 T), s.val ≤ t.val →
    ∫ ω, process s ω * process t ω ∂μ = s.val * (T - t.val) / T

/-! ## Ornstein-Uhlenbeck Process -/

/-- Ornstein-Uhlenbeck process: dX_t = -θ X_t dt + σ dW_t

    The explicit solution is:
    X_t = X_0 e^{-θt} + σ ∫₀ᵗ e^{-θ(t-s)} dW_s

    Key properties:
    1. Conditional mean: E[X_t | X_0] = X_0 e^{-θt}  (mean-reversion)
    2. Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt})
    3. Stationary distribution: N(0, σ²/2θ)
    4. Gaussian process (all finite-dimensional distributions are Gaussian) -/
structure OrnsteinUhlenbeck (Ω : Type*) [MeasurableSpace Ω]
    (μ : Measure Ω) (θ σ : ℝ) (hθ : 0 < θ) (hσ : 0 < σ) where
  /-- The underlying filtration -/
  F : Filtration Ω ℝ
  /-- The process -/
  process : ℝ → Ω → ℝ
  /-- Driven by Brownian motion -/
  driving_BM : BrownianMotion Ω μ
  /-- Adapted to the filtration -/
  adapted : ∀ t : ℝ, @Measurable Ω ℝ (F.σ_algebra t) _ (process t)
  /-- Mean-reverting property: E[X_t | F_0] = X_0 e^{-θt}
      Expressed via conditional expectation: for all F_0-measurable sets A,
      ∫_A X_t dμ = ∫_A X_0 e^{-θt} dμ -/
  mean_reversion : ∀ t : ℝ, 0 ≤ t →
    ∀ A : Set Ω, @MeasurableSet Ω (F.σ_algebra 0) A →
    ∫ ω in A, process t ω ∂μ = ∫ ω in A, process 0 ω * Real.exp (-θ * t) ∂μ
  /-- X_t is Gaussian given X_0 -/
  gaussian_conditional : ∀ t : ℝ, 0 ≤ t →
    Probability.IsGaussian (fun ω => process t ω - process 0 ω * Real.exp (-θ * t)) μ
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))

/-- Conditional variance: Var(X_t | X_0) = (σ²/2θ)(1 - e^{-2θt}).
    Derived from `gaussian_conditional` (it is literally the variance_eq field). -/
theorem ou_conditional_variance {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    ∫ ω, (X.process t ω - X.process 0 ω * Real.exp (-θ * t))^2 ∂μ =
      (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) := by
  have h := (X.gaussian_conditional t ht).variance_eq
  simp only [sub_zero] at h
  exact h

/-- In the stationary regime (t → ∞), Var(X_t) → σ²/(2θ) -/
theorem ou_stationary_variance {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) :
    Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds (σ^2 / (2 * θ))) := by
  have h : Filter.Tendsto (fun t => Real.exp (-2 * θ * t)) Filter.atTop (nhds 0) := by
    have hcoef : -2 * θ < 0 := by linarith
    have hmul : Filter.Tendsto (fun t => -2 * θ * t) Filter.atTop Filter.atBot :=
      (Filter.tendsto_const_mul_atBot_of_neg hcoef).mpr Filter.tendsto_id
    exact Real.tendsto_exp_atBot.comp hmul
  have h2 : Filter.Tendsto (fun t => 1 - Real.exp (-2 * θ * t)) Filter.atTop (nhds (1 - 0)) :=
    Filter.Tendsto.sub tendsto_const_nhds h
  simp only [sub_zero] at h2
  have h3 : Filter.Tendsto (fun t => (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)))
      Filter.atTop (nhds ((σ^2 / (2 * θ)) * 1)) :=
    Filter.Tendsto.const_mul _ h2
  simp only [mul_one] at h3
  exact h3

/-- OU process is Gaussian with specific mean and variance -/
theorem ou_is_gaussian {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    Probability.IsGaussian (fun ω => X.process t ω - X.process 0 ω * Real.exp (-θ * t)) μ
      0 ((σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))) :=
  X.gaussian_conditional t ht

/-- The variance is always non-negative and bounded by σ²/(2θ) -/
theorem ou_variance_bounds {Ω : Type*} [MeasurableSpace Ω]
    {μ : Measure Ω} {θ σ : ℝ} {hθ : 0 < θ} {hσ : 0 < σ}
    (_X : OrnsteinUhlenbeck Ω μ θ σ hθ hσ) (t : ℝ) (ht : 0 ≤ t) :
    0 ≤ (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ∧
    (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t)) ≤ σ^2 / (2 * θ) := by
  constructor
  · -- Non-negativity: (σ²/2θ) ≥ 0 and (1 - e^{-2θt}) ≥ 0 for t ≥ 0
    apply mul_nonneg
    · apply div_nonneg (sq_nonneg σ)
      linarith
    · have hexp : Real.exp (-2 * θ * t) ≤ 1 := by
        rw [Real.exp_le_one_iff]
        have : 0 ≤ 2 * θ * t := by nlinarith
        linarith
      linarith
  · -- Upper bound: (1 - e^{-2θt}) ≤ 1
    have hexp_pos : 0 < Real.exp (-2 * θ * t) := Real.exp_pos _
    have h1 : 1 - Real.exp (-2 * θ * t) ≤ 1 := by linarith
    have hcoef : 0 ≤ σ^2 / (2 * θ) := by
      apply div_nonneg (sq_nonneg σ)
      linarith
    calc (σ^2 / (2 * θ)) * (1 - Real.exp (-2 * θ * t))
        ≤ (σ^2 / (2 * θ)) * 1 := by apply mul_le_mul_of_nonneg_left h1 hcoef
      _ = σ^2 / (2 * θ) := mul_one _

end SPDE
